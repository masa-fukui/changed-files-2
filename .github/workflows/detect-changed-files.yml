name: Detect Changed Files

on:
  workflow_dispatch:
    inputs:
      include_patterns:
        description: 'Patterns to include (one per line or JSON array). Use "*" for all files.'
        required: false
        default: '*'
      exclude_patterns:
        description: 'Patterns to exclude (one per line or JSON array). Optional.'
        required: false
        default: ''
      base_ref:
        description: 'Base branch to compare against'
        required: false
        default: 'main'
  workflow_call:
    inputs:
      include_patterns:
        description: 'Patterns to include (multiline string). Use "*" for all files.'
        type: string
        required: false
        default: '*'
      exclude_patterns:
        description: 'Patterns to exclude (multiline string). Optional.'
        type: string
        required: false
        default: ''
      base_ref:
        description: 'Base branch to compare against'
        type: string
        required: false
        default: 'main'
    outputs:
      has_changes:
        description: 'Whether any files matched the patterns'
        value: ${{ jobs.detect-changes.outputs.has_changes }}
      changed_files:
        description: 'Newline-separated list of changed files'
        value: ${{ jobs.detect-changes.outputs.changed_files }}
      changed_count:
        description: 'Number of changed files'
        value: ${{ jobs.detect-changes.outputs.changed_count }}

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.detect.outputs.has_changes }}
      changed_files: ${{ steps.detect.outputs.changed_files }}
      changed_count: ${{ steps.detect.outputs.changed_count }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed files
        id: detect
        shell: bash
        run: |
          set -e

          # ============================================
          # 1. Get changed files from git
          # ============================================
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE_REF="${{ github.event.pull_request.base.sha }}"
            HEAD_REF="${{ github.event.pull_request.head.sha }}"
          else
            BASE_REF="origin/${{ github.event.inputs.base_ref || 'main' }}"
            HEAD_REF="HEAD"
          fi

          echo "Comparing $HEAD_REF against $BASE_REF"
          git diff --name-only "$BASE_REF" "$HEAD_REF" > all_changed_files.txt

          echo "All changed files:"
          cat all_changed_files.txt

          # ============================================
          # 2. Parse include/exclude patterns
          # ============================================
          INCLUDE_INPUT='${{ inputs.include_patterns || github.event.inputs.include_patterns }}'
          EXCLUDE_INPUT='${{ inputs.exclude_patterns || github.event.inputs.exclude_patterns }}'

          # Default to match all if no patterns provided
          [ -z "$INCLUDE_INPUT" ] || [ "$INCLUDE_INPUT" = "null" ] && INCLUDE_INPUT='*'

          # Parse patterns (handles JSON arrays or newline-separated strings)
          parse_patterns() {
            [ -z "$1" ] && return
            echo "$1" | jq -r '.[]' 2>/dev/null || echo "$1"
          }

          readarray -t INCLUDE < <(parse_patterns "$INCLUDE_INPUT")
          readarray -t EXCLUDE < <(parse_patterns "$EXCLUDE_INPUT")

          echo "Include patterns (${#INCLUDE[@]}):"
          printf '  - %s\n' "${INCLUDE[@]}"
          echo "Exclude patterns (${#EXCLUDE[@]}):"
          printf '  - %s\n' "${EXCLUDE[@]}"

          # ============================================
          # 3. Pattern matching function
          # ============================================
          matches() {
            local file="$1"
            shift
            local patterns=("$@")

            [ ${#patterns[@]} -eq 0 ] && return 1

            for pattern in "${patterns[@]}"; do
              pattern=$(echo "$pattern" | xargs)
              [ -z "$pattern" ] && continue

              # Match all wildcards
              [[ "$pattern" =~ ^(\*|\*\*|\*\*/\*)$ ]] && return 0

              # Convert glob to regex
              local regex="$pattern"
              regex="${regex//\*\*/.*}"      # ** matches any path
              regex="${regex//\*/[^/]*}"     # * matches within directory

              [[ "$file" =~ $regex ]] && return 0
            done

            return 1
          }

          # ============================================
          # 4. Filter files by patterns
          # ============================================
          > filtered_files.txt

          while IFS= read -r file; do
            if matches "$file" "${INCLUDE[@]}"; then
              if [ ${#EXCLUDE[@]} -gt 0 ] && matches "$file" "${EXCLUDE[@]}"; then
                echo "  [EXCLUDED] $file"
              else
                echo "  [INCLUDED] $file"
                echo "$file" >> filtered_files.txt
              fi
            else
              echo "  [SKIPPED] $file"
            fi
          done < all_changed_files.txt

          echo ""
          echo "=========================================="
          echo "Filtered changed files:"
          cat filtered_files.txt || echo "(none)"
          echo "=========================================="

          # ============================================
          # 5. Set workflow outputs
          # ============================================
          if [ -s filtered_files.txt ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "changed_files<<EOF" >> $GITHUB_OUTPUT
            cat filtered_files.txt >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            echo "changed_count=$(wc -l < filtered_files.txt | xargs)" >> $GITHUB_OUTPUT
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "changed_files=" >> $GITHUB_OUTPUT
            echo "changed_count=0" >> $GITHUB_OUTPUT
          fi
